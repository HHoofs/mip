from __future__ import annotations

from typing import Iterable, Literal, Protocol, Union, cast, overload


Expresionable = Union[int, 'Var', 'LinearExpresion', 'QuadraticExpresion']
Expresion = Union['LinearExpresion', 'QuadraticExpresion']


class IndexedVariable(Protocol):
    def __iter__(self) -> Iterable[Var]:
        ...

    def values(self) -> Iterable[Var]:
        ...

    def sum(self, *args) -> Var: ...


class Var(Protocol):
    def __add__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __radd__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __iadd__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __sub__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __rsub__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __isub__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __neg__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __mul__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __imul__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __rmul__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __div__(self, x: Union[int, Var], /) -> LinearExpresion: ...

    def __pow__(self, x: Literal[2], /) -> LinearExpresion: ... 


class LinearExpresion(Protocol):
    def __add__(self, x: Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __radd__(self, x: Union[Var, float], /) -> LinearExpresion: ...

    def __iadd__(self, x: Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __sub__(self, x: Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __rsub__(self, x: Union[Var, float], /) -> LinearExpresion: ...

    def __isub__(self, x:  Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __neg__(self) -> LinearExpresion: ...

    @overload
    def __mul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __mul__(self, x: Union[LinearExpresion, Var], /) -> QuadraticExpresion: ...
    def __mul__(self, x: Union[LinearExpresion, Var, float], /) -> Expresion: ...

    @overload
    def __imul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __imul__(self, x: Union[LinearExpresion, Var], /) -> QuadraticExpresion: ...
    def __imul__(self, x: Union[LinearExpresion, Var, float], /) -> Expresion: ...  # type: ignore

    @overload
    def __rmul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __rmul__(self, x: Var, /) -> QuadraticExpresion: ...
    def __rmul__(self, x: Union[Var, float], /) -> Expresion: ...

    def __div__(self, x: int, /) -> LinearExpresion: ...

    def __pow__(self, x: Literal[2], /) -> QuadraticExpresion: ...


class QuadraticExpresion(Protocol):
    def __add__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __radd__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __iadd__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __sub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __rsub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __isub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __neg__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __mul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __rmul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __imul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __div__(self, x: float, /) -> QuadraticExpresion: ...

@overload
def sum(iterable: Iterable[Union[LinearExpresion, Var, float]]) -> LinearExpresion: ...
@overload
def sum(iterable: Iterable[Expresionable]) -> Expresion: ...
def sum(iterable):
    pass


print(sum([1,2,3]))


# a: Var = cast(L`iteral[3], Var)
# b: Var = cast(Literal[3], Var)
# c = (a, b)
# exp = a + 2

# reveal_type(b + exp)
# reveal_type(a + b)
# d = sum(c)
# reveal_type(d)

# import gurobipy as gp
# from gurobipy import GRB
# m = gp.Model("mip1") 
# x = m.addVar(vtype=GRB.BINARY, name="x")
# y = m.addVar(vtype=GRB.BINARY, name="y")
# z = m.addVar(vtype=GRB.BINARY, name="z")`