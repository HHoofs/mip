from __future__ import annotations

from typing import Iterable, Literal, Protocol, TypeVar, cast, overload

_T_contra = TypeVar("_T_contra", contravariant=True)


class IndexedVariable(Protocol):
    def __iter__(self) -> Iterable[Var]:
        ...

    def values(self) -> Iterable[Var]:
        ...

    def sum(self, *args) -> Var: ...

class Expresion(Protocol): ...

class LinearExpresion(Expresion, Protocol): ...

class QuadraticExpresion(Expresion, Protocol): ...


class Var(Protocol):
    def __add__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __radd__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __iadd__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __sub__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __rsub__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __isub__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __neg__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __mul__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __rmul__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __imul__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __div__(self, x: _T_contra, /) -> LinearExpresion: ...

    @overload
    def __pow__(self, x: Literal[2], /) -> LinearExpresion: ...

    @overload
    def __pow__(self, x: _T_contra, /) -> QuadraticExpresion: ...

    def __pow__(self, x: _T_contra, /) -> LinearExpresion: ...

a: Var = cast(Literal[3], Var)
b: Var = cast(Literal[3], Var)

reveal_type(a ** b)