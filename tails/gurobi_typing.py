from __future__ import annotations

from typing import Iterable, Literal, Protocol, TypeVar, Union, cast, overload

_T_contra = TypeVar("_T_contra", contravariant=True)


Expresionable = Union[int, 'Var', 'LinearExpresion', 'QuadraticExpresion']
Expresion = Union['LinearExpresion', 'QuadraticExpresion']


class IndexedVariable(Protocol):
    def __iter__(self) -> Iterable[Var]:
        ...

    def values(self) -> Iterable[Var]:
        ...

    def sum(self, *args) -> Var: ...


class Var(Protocol):
    def __add__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __radd__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __iadd__(self, x: _T_contra, /) -> LinearExpresion: ...

    def __sub__(self, x: int, /) -> LinearExpresion: ...

    def __rsub__(self, x: int, /) -> LinearExpresion: ...

    def __isub__(self, x: int, /) -> LinearExpresion: ...

    def __neg__(self, x: int, /) -> LinearExpresion: ...

    def __mul__(self, x: int, /) -> LinearExpresion: ...

    def __imul__(self, x: int, /) -> LinearExpresion: ...

    def __rmul__(self, x: int, /) -> LinearExpresion: ...

    def __div__(self, x: int, /) -> LinearExpresion: ...

    def __pow__(self, x: Literal[2], /) -> LinearExpresion: ... 


class LinearExpresion(Protocol):
    def __add__(self, x: Union[LinearExpresion, float], /) -> LinearExpresion: ...

    def __radd__(self, x: Union[Var, float], /) -> LinearExpresion: ...

    def __iadd__(self, x: Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __sub__(self, x: Union[LinearExpresion, float], /) -> LinearExpresion: ...

    def __rsub__(self, x: Union[Var, float], /) -> LinearExpresion: ...

    def __isub__(self, x:  Union[LinearExpresion, Var, float], /) -> LinearExpresion: ...

    def __neg__(self) -> LinearExpresion: ...

    @overload
    def __mul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __mul__(self, x: Union[LinearExpresion, Var], /) -> QuadraticExpresion: ...
    def __mul__(self, x: Union[LinearExpresion, Var, float], /) -> Expresion: ...

    @overload
    def __imul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __imul__(self, x: Union[LinearExpresion, Var], /) -> QuadraticExpresion: ...
    def __imul__(self, x: Union[LinearExpresion, Var, float], /) -> Expresion: ...  # type: ignore

    @overload
    def __rmul__(self, x: float, /) -> LinearExpresion: ...
    @overload
    def __rmul__(self, x: Var, /) -> QuadraticExpresion: ...
    def __rmul__(self, x: Union[Var, float], /) -> Expresion: ...

    def __div__(self, x: int, /) -> LinearExpresion: ...

    def __pow__(self, x: Literal[2], /) -> QuadraticExpresion: ...


class QuadraticExpresion(Protocol):
    def __add__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __radd__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __iadd__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __sub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __rsub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __isub__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __neg__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __mul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __rmul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __imul__(self, x: Expresionable, /) -> QuadraticExpresion: ...

    def __div__(self, x: float, /) -> QuadraticExpresion: ...


a: Var = cast(Literal[3], Var)
b: Var = cast(Literal[3], Var)
c: list[Var] = []
reveal_type(sum(c))

exp = a ** 2

reveal_type(a + exp)
reveal_type(exp ** 2)

expp = exp ** 2
reveal_type(2 + expp + 2)

# import gurobipy as gp
# from gurobipy import GRB
# m = gp.Model("mip1") 
# x = m.addVar(vtype=GRB.BINARY, name="x")
# y = m.addVar(vtype=GRB.BINARY, name="y")
# z = m.addVar(vtype=GRB.BINARY, name="z")